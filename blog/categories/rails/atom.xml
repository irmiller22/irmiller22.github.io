<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Archaic Positives]]></title>
  <link href="http://irmiller22.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://irmiller22.github.io/"/>
  <updated>2016-04-03T15:38:05-04:00</updated>
  <id>http://irmiller22.github.io/</id>
  <author>
    <name><![CDATA[Ian Miller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RSpec Testing for a JSON API]]></title>
    <link href="http://irmiller22.github.io/blog/2014/04/18/rspec-testing-for-a-json-api/"/>
    <updated>2014-04-18T10:31:45-04:00</updated>
    <id>http://irmiller22.github.io/blog/2014/04/18/rspec-testing-for-a-json-api</id>
    <content type="html"><![CDATA[<p>I am in the process of building out a JSON API for a registry application, that, when pinged by Salesforce, will fire off emails to prospective Flatiron students that notify them of their acceptance into the Flatiron School program. One thing that I noticed is that there aren&rsquo;t many resources out there for setting up a testing environment and eventually building out a JSON API via Ruby on Rails. Hopefully this resource will shed a little more light on how to accomplish that.</p>

<p>The first step is to integrate a Rails serializer in order to encapsulate the JSON serialization of objects. We first install the <code>active_model_serializers</code> gem into the Gemfile, and then bundle. Now, for each model that we want to serialize for JSON serialization, we need to create a serializer: <code>rails g serializer student</code>.</p>

<p>Inside of the serializer file that has just been generated, we need to add in student attributes that will be defined and visible in the JSON API.</p>

<p><code>ruby app/serializers/student_serializer.rb
class StudentSerializer &lt; ActiveModel::Serializer
  attributes :id, :first_name, :last_name, :email
end
</code></p>

<p>For example, this is how the JSON data will be represented on the API tree, based upon the order of attributes in the <code>student_serializer.rb</code> file above:</p>

<p>```ruby JSON data for student
  students:</p>

<pre><code>[
  {
    id: 4,
    first_name: "Doctor",
    last_name: "Who",
    email: "doctor_who@whoville.com"
  }
]
</code></pre>

<p>```</p>

<p>There is a key called students, and inside of its value store, it holds a collection of student objects. Inside of the array collection, there is 1 student with an id of 4, first name of &ldquo;Doctor&rdquo;, last name of &ldquo;Who&rdquo;, and an email &ldquo;<a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#100;&#x6f;&#x63;&#116;&#111;&#114;&#95;&#119;&#x68;&#x6f;&#x40;&#119;&#104;&#111;&#x76;&#105;&#108;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#100;&#111;&#99;&#x74;&#111;&#114;&#x5f;&#x77;&#x68;&#x6f;&#x40;&#x77;&#x68;&#x6f;&#x76;&#x69;&#108;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a>&rdquo;. This is a demonstrative example of how the JSON object data will be rendered when the API is pinged.</p>

<p>In the <code>app/controllers</code> directory, I created a new folder system that allows for semantic versioning of the API. Currently my directory looks like this: <code>app/controllers/api/v1</code>. Inside of that folder structure, I have one file: <code>students_controller.rb</code>. We will come back to these files once we start building out our controller actions.</p>

<p>Next, I set up the routes for the <code>students</code> resource. My <code>config/routes.rb</code> file looks like this currently:</p>

<p>```ruby config/routes.rb
namespace :api do
  namespace :v1 do</p>

<pre><code>resources :students, only: [:index, :show, :create]
</code></pre>

<p>  end
end<br/>
```</p>

<p>This is the basic setup for the API itself. At this point in the API development, we&rsquo;re only concerned with the <code>index</code>, <code>show</code>, and <code>create</code> actions for the API Students Controller. Now, we&rsquo;ll go ahead and set up the RSpec tests for the controller.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>describe API::V1::StudentsController do
  describe &ldquo;GET &lsquo;index&rsquo; &rdquo; do</p>

<pre><code>it "returns a successful 200 response" do
  pending
end

it "returns all the students" do
  pending
end
</code></pre>

<p>  end
```</p>

<p>This describe block refers to the index action of the controller. In this block, we are testing for two expectations: for the JSON response for the index action to return a 200 status code, and for the JSON response to return the correct number of students that exist in the test database.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
require &lsquo;spec_helper&rsquo;</p>

<p>describe API::V1::StudentsController do
  describe &ldquo;GET &lsquo;index&rsquo; &rdquo; do</p>

<pre><code>it "returns a successful 200 response" do
   get :index, format: :json
  expect(response).to be_success
end

it "returns all the students" do
  FactoryGirl.create_list(:student, 5)
  get :index, format: :json
  parsed_response = JSON.parse(response.body)
  expect(parsed_response['students'].length).to eq(5)
end
</code></pre>

<p>  end
```</p>

<p>In order to get these tests passing, we first need to submit a get request for the <code>index</code> action in a JSON format. We first expect the response to be successful, or more specifically, to result in a 200 status code.</p>

<p>We also need to test whether or not it returns all of the existing students in the test database. I&rsquo;ve used the FactoryGirl gem to mock out the student list <code>create_list(:student, 5)</code>. I&rsquo;ve also set up the <code>parsed_response</code> variable, which will translate the response body in JSON format into a more readable format. Then I&rsquo;ve set the expectation that the <strong>length</strong> of the <code>parsed_response[students]</code> should be equal to 5, as specified in the <code>FactoryGirl.create_list(:student, 5)</code> line.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
  describe &ldquo;GET &lsquo;show&rsquo; &rdquo; do</p>

<pre><code>it "returns a successful 200 response" do
  pending
end

it "returns data of an single student" do
  pending
end

it "returns an error if the student does not exist" do
  pending
end
</code></pre>

<p>  end
```</p>

<p>This block refers to the show action. I am testing for three specific expectations: a successful JSON response to return a 200 status code, a successful response to return the correct student JSON object, and for the JSON response to return an error message for a student JSON object that doesn&rsquo;t exist.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
  describe &ldquo;GET &lsquo;show&rsquo; &rdquo; do</p>

<pre><code>let(:student) { create(:student) }

it "returns a successful 200 response" do
  get :student, id: student, format: :json
  expect(response).to be_success
end

it "returns data of an single student" do
  get :student, id: student, format: :json
  parsed_response = JSON.parse(response.body)
  expect(parsed_response['student']).to_not be_nil
end

it "returns an error if the student does not exist" do
  get :student, id: 10 , format: :json
  parsed_response = JSON.parse(response.body)
  expect(parsed_response['error']).to eq("Student does not exist")
  expect(response).to be_not_found
end
</code></pre>

<p>  end
```</p>

<p>We&rsquo;ve built out a student mock using FactoryGirl, and will be using this to test whether or not the <code>show</code> method returns the correct student from the test database based on the student&rsquo;s ID. For each test, we are submitting a get request for the student we mocked out earlier, and we should expect a 200 response for the first test, and for <code>parsed_response['student']</code> to essentially be a valid student object returned from the test database. For the third test, we are asking to return a student with an ID of 10, which doesn&rsquo;t exist in our database. We should expect an error messaged from <code>parsed_response['error']</code>, and we should also expect the response to return a message saying that the object was not found.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
  describe &ldquo;POST &lsquo;create&rsquo; &rdquo; do</p>

<pre><code>context "correct email format" do
  it "returns a successful json string with success message" do
    pending
  end
end

context "incorrect email format" do
  it "returns an error if an incorrect email format is submitted" do
    pending
  end  
end
</code></pre>

<p>  end
end
```</p>

<p>This block is describing the create method, which will take in an email address parameter. If the email address is valid, then it will fire off an email to that email address, and then fire off a <strong>success</strong> message within a JSON response. If the email address is invalid, then it won&rsquo;t fire off the email, and will render an <strong>invalid</strong> message within a JSON response.</p>

<p>```ruby spec/controllers/api/v1/students_controller_spec.rb
  describe &ldquo;POST &lsquo;create&rsquo; &rdquo; do</p>

<pre><code>context "correct email format" do
  it "returns a successful json string with success message" do
    post :create, { email: "newstudent@example.com" }
    expect(response).to be_success
    parsed_response = JSON.parse(response.body)
    expect(parsed_response['success']).to eq("Accepted email format.")
  end
end

context "incorrect email format" do
  it "returns an error if an incorrect email format is submitted" do
    post :create, { email: "new@studentexample" }
    parsed_response = JSON.parse(response.body)
    expect(response).to be_bad_request
    expect(parsed_response['invalid']).to eq("Invalid email format.")
  end  
end
</code></pre>

<p>  end
end
```</p>

<p>In the first test, we&rsquo;re passing in a valid email address inside of the post request for the <code>create</code> action. If it&rsquo;s valid, then we expect the JSON response to have a 200 status code, and we also expect <code>parsed_response</code> to have a <strong>success</strong> message as well. The second test passes in an invalid email address. We expect the JSON response to return a bad request status, more specifically a 400 status code, as well as a <strong>invalid</strong> message inside of the <code>parsed_response</code>.</p>

<p>In order to make all of these tests pass, here&rsquo;s how the corresponding <code>app/controllers/api/v1/students_controller.rb</code> file looks:</p>

<p>```ruby controllers/api/v1/students_controller.rb
module API::V1
  class StudentsController &lt; ApplicationController</p>

<pre><code>before_action :find_student, only: [:student]

def index
  @students = Student.all
  render json: @students
end

def show
  render json: @student
end

def create
  if valid_email?(params[:email])
    send_acceptance_email(params[:email])
    render json: { success: "Accepted email format." }
  else
    render json: { invalid: "Invalid email format." }, status: :bad_request
  end
end

private

def find_student
  @student = Student.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    render json: { error: "Student does not exist" }, status: :not_found
end

def valid_email?(email_address)
  !!(email_address =~ /.+\@.+\..+/)
end

def send_acceptance_email(email)
  NewStudentMailer.acceptance_email(email).deliver
end
</code></pre>

<p>  end
end
```</p>

<p>The <code>index</code>, <code>show</code>, and <code>create</code> methods should be pretty straightforward, but perhaps I should elaborate more on the private methods. Within the context of building an API, we only need to focus on two: <code>find_student</code> and <code>valid_email?(email_address)</code>.</p>

<p>The <code>find_student</code> method will query the Student model and its corresponding ActiveRecord database in order to find the student object with the ID attribute specified in params. In the event that it cannot find that corresponding student and Rails throws a <code>ActiveRecord::RecordNotFound</code> error, then it will execute a rescue clause that will render a JSON response with two components: the message &ldquo;Student does not exist&rdquo; and a 404 status code (&ldquo;Not Found&rdquo;).</p>

<p>The &lsquo;valid_email?(email_address)&rsquo; method is simply a regex that will parse a parameter passed in, and determine whether or not it is a valid email address. If it is valid, it will fire off an email in the <code>send_acceptance_email(email)</code> method, but if it is not valid, then it will render a JSON response with an invalid format error message.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strong Params in Rails]]></title>
    <link href="http://irmiller22.github.io/blog/2014/04/01/strong-params-in-rails/"/>
    <updated>2014-04-01T23:10:39-04:00</updated>
    <id>http://irmiller22.github.io/blog/2014/04/01/strong-params-in-rails</id>
    <content type="html"><![CDATA[<p>Recently, I ran into issues trying to pass a new variable into my params hash after integrating Devise into my app, so I decided to do a refresher of strong params. Strong params was implemented in Rails so that users could not maliciously manipulate form submissions via form fields.</p>

<p>Strong parameters was implemented in Rails 3 via <code>whitelisting</code>, which is the act of permitting specific attributes that can be passed into the params hash via the model. In Rails 4, the responsibility of <code>whitelisting</code> has now been passed to the controller.</p>

<p>Typically, we have a private method inside of the controller that delegates the <code>whitelisting</code> that should take place.</p>

<p>For example:</p>

<p>```ruby UsersController
private</p>

<p>def resource_params
  params.require(:user).permit(:name, :age, :email)
end
```</p>

<p>The <code>require</code> statement inside the <code>resource_params</code> method performs the parameter validation for the user parameter. If the user parameter exists, then it will go on and validate each of the attributes. If the user parameter does not exist, then it will throw an <code>ActionController::ParameterMissing</code> error and return a 400 status code response.</p>

<p>Additionally, the <code>permit</code> method will strip out any attributes that do not belong inside of the params. For example, if we tried to include a <code>:admin</code> attribute inside of the <code>permit</code> method, it will not be passed into the params.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Caching]]></title>
    <link href="http://irmiller22.github.io/blog/2014/03/19/rails-caching/"/>
    <updated>2014-03-19T09:27:04-04:00</updated>
    <id>http://irmiller22.github.io/blog/2014/03/19/rails-caching</id>
    <content type="html"><![CDATA[<h1>Caching in Rails</h1>

<h2>What is Caching?</h2>

<p>It is a tool that allows you to avoid extensive database querying on a page by storing elements of a page in memory and retrieving that memory store each time that page is visited. It enables faster page loading on refresh, and saves resources.</p>

<h2>Cache Types in Rails</h2>

<h3>Page Caching</h3>

<p>This is a Rails mechanism that allows a request for a generated page to be fulfilled by the webserver. This has limited uses, and can&rsquo;t be used with pages that have <code>before</code> filters (such as pages that require authentication). It also requires that cache expiration be set explicitly. Since Rails 4, the page caching feature has been removed into a separate gem called <code>actionpack-page</code>.</p>

<h3>Action Caching</h3>

<p>Action caching is used where page caching can&rsquo;t be utilized &mdash; such as with pages that require authentication. It is very similar to page caching, except that the incoming request hits the Rails stack so that <code>before</code> filters can be executed before the cache is served. Since Rails 4, the action caching feature has been removed into a separate gem called <code>actionpack-action</code>.</p>

<h3>Fragment Caching</h3>

<p>Fragment caching allows a fragment of view logic to be wrapped inside of a cache block and served out of the cache store when the next page request comes calling. Basically, the cache block is wrapped around logic inside of your view, and that cached view logic will be served to the page view until it expires. Then the cache process will start over again.</p>

<h2>Cache Setup</h2>

<h3>Configuration Settings</h3>

<p>You can set up your app&rsquo;s default cache store by calling <code>config.cache_store=</code> inside <code>config/application.rb</code> or inside of your environment files in <code>config/environments/*.rb</code>.</p>

<h3>Cache::Store</h3>

<p>This is the foundation for interacting with the Rails cache. The class in Rails is provided via <code>ActiveSupport::Cache::Store</code>. There are four primary methods: <code>read</code>, <code>write</code>, <code>delete</code>, <code>exist?</code>, and <code>fetch</code>. The <code>fetch</code> method takes a block and will return an existing cache, or it will evaluate the block and write the result to the cache if a cache doesn&rsquo;t exist previously.</p>

<p>There are four options that can be passed in to the <code>config.cache_store=</code> configuration. They are:
&ndash; <code>:namespace</code> &ndash; Option is used to create a namespace within the cache store (useful when cache is shared with other applications). Default is the application name and Rails environment.
&ndash; <code>:compress</code> &ndash; Used to indicate that compression should be used in the cache (useful for transferring large caches)
&ndash; <code>:compress_threshold</code> &ndash; Used int conjunction with <code>:compress</code> to indicate a threshold under which caches should not be compressed (default is 16 kilobytes)
&ndash; <code>:expires_in</code> &ndash; Sets an expiration time in seconds
&ndash; <code>:race_condition_ttl</code> &ndash; Used in conjunction with <code>:expires_in</code> option to prevent race conditions when a cache expires (basically prevents multiple processes from regenerating cache entries simultaneously)</p>

<h3>Cache::MemoryStore</h3>

<p>This stores cache entries in memory. This has a size limit specified by the <code>:size</code> option (default size is 32 megabytes). When the cache exceeds the size limit, a cleanup will occur. This is not ideal for large app deployments, and typically works best for small, low traffic sites.</p>

<p>This has to be specified in configurations via:
&ndash; <code>config.cache_store = :memory_store, { size: 128.megabytes }</code></p>

<h2>Heroku Cache Configuration Setup</h2>

<p>In order to enable caching with Heroku, it works best with <code>Memcachier</code>, which is a Heroku add-on. <code>Memcachier</code> essentially manages and scales clusters of memcache servers for Heroku apps. See the link below for setup instructions.</p>

<ul>
<li><a href="" title="https://devcenter.heroku.com/articles/rack-cache-memcached-rails31#configure-rails-cache-store">Link to Heroku Memcachier Setup</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controller Testing Via RSpec]]></title>
    <link href="http://irmiller22.github.io/blog/2014/02/27/controller-testing-via-rspec/"/>
    <updated>2014-02-27T10:01:37-05:00</updated>
    <id>http://irmiller22.github.io/blog/2014/02/27/controller-testing-via-rspec</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been testing controllers pretty often over the last few weeks, and wanted to write a few reminders to my future self. I&rsquo;ve been testing an app at work with RSpec, and have gleaned a few best practices to integrate into my unit tests for controllers.</p>

<p>First off, the purpose of controller testing is to test the controller actions directly and see what they do. For example, if we are testing a redirect, we want to make sure that the controller action is redirecting to the right path. It&rsquo;s important to follow the AAA pattern: Arrange, Act, and Assert. You set up the test by arranging a <code>before(:each)</code> statement, and setting up the data needed to execute a test via let blocks. Then you act upon the arranged data by manipulating it to the test&rsquo;s specifications. Then you assert that the arranged data should result in some specific action or result. Arrange, act, and assert.</p>

<p>Another tip to keep in mind. Avoid before(:all) statements whenever possible, because you hardly will ever need it, and it sort of goes against Sandi Metz&rsquo;s Single Responsibility Principle (SRP). If you ever actually do need it, you are most likely dealing with a very extraordinary circumstance. The before(:all) block can affect test-data stability due to unwanted side effects.</p>

<p>For BDD/Rspec language, prefer to use active language instead of passive language. Of course the system should do something. Let&rsquo;s write tests where the language asserts definitively that it does or does not do something, thereby documenting not what our system should do but what it does do. It&rsquo;s important to be as clear and succinct in our language about what our expectations are.</p>

<p>Finally, a small but important distinction between <code>let()</code> and <code>let!()</code>. An object defined in a <code>let()</code> statement is lazily evaluated, meaning that it won&rsquo;t instantiate that object until it has been called in a RSpec test. However, an object defined in a <code>let!()</code> statement is forcefully evaluated, and the object will be instantiated once the statement has been invoked.</p>

<p>Hopefully these thoughts and insights will prove useful to someone, as they will for me in the near future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Link Shortener App]]></title>
    <link href="http://irmiller22.github.io/blog/2014/02/02/basic-rails-link-shortener-app/"/>
    <updated>2014-02-02T15:05:05-05:00</updated>
    <id>http://irmiller22.github.io/blog/2014/02/02/basic-rails-link-shortener-app</id>
    <content type="html"><![CDATA[<p>Over the last few days, there were primarily two things that I wanted to delve into conceptually and understand: MongoDB and the logic behind a link shortener. I decided to combine the two of these and create a simple Rails app in which you could shorten links.</p>

<p>So, what is MongoDB? MongoDB is what&rsquo;s called a <code>NoSQL</code> database technology. A <code>NoSQL</code> database doesn&rsquo;t rely on a series of rows and columns within tables like a <code>SQL</code>, or relational, database does. <code>NoSQL</code> databases can store information in a variety of ways, but in the case of MongoDB, it stores it via a document database. Each respective document that you enter into the Mongo database is very similar to a JSON object in that they have a key-value store. However, the primary difference is that you do not access the documents via the key (think of accessing elements in a hash), but rather you query the database for these document elements.</p>

<p>I started out the app by generating a new Rails app via <code>rails g new link_shortener</code>. Once the app is generated, you can also use the Mongoid gem to generate the config file for the MongoDB database via <code>rails g mongoid:config</code>. Once you generate the config file, you can read through the file, available at <code>mongoid.yml</code> within the app, for an in-depth explanation of Mongoid&rsquo;s capabilities.</p>

<p>Next step is to create the model. Since we have an app t hat is going to shorten URLs, we need to create a URL model, so that each URL can be represented within Ruby/Rails as an object.</p>

<p>In Rails, querying the database is very much like that of ActiveRecord. The same model commands, such as <code>where, find, find_or_create_by, save</code> are very much in place. Look at the Mongoid documentation to find out more.</p>

<p>Let&rsquo;s test it out.</p>

<p>```ruby Url Model
u = Url.new
u.url = &ldquo;<a href="http://irmiller22.github.io">http://irmiller22.github.io</a>&rdquo;</p>

<h1>=> #<Url _id: 52eeacee49524d08ce010000, url: "http://irmiller22.github.io"></h1>

<p>u.save
Url.where(:url => &ldquo;<a href="http://irmiller22.github.io">http://irmiller22.github.io</a>&rdquo;)</p>

<h1>=> #&lt;Mongoid::Criteria</h1>

<h1>=>  selector: {&ldquo;url&rdquo;=>&ldquo;<a href="http://irmiller22.github.io">http://irmiller22.github.io</a>&rdquo;}</h1>

<h1>=>  options:  {}</h1>

<h1>=>  class:    Url</h1>

<h1>=>  embedded: false></h1>

<p>```</p>

<p>Now that you&rsquo;ve set up a model to take care of persisting data to the database, we need a controller to eventually take the input, generate the right output, and getting the data to the appropriate routing destination. Let&rsquo;s generate the new controller: <code>rails g controller urls new</code>. Typically when you generate a controller, you generate all 7 of the RESTful actions, but in this case we&rsquo;re only interested in testing one action for the moment: new. This generates the following:</p>

<p><code>ruby UrlsController
class UrlsController &lt; ApplicationController
  def new
  end
end
</code></p>

<p>```ruby routes.rb
get &ldquo;urls/new&rdquo;</p>

<h1>we will modify this to the following:</h1>

<h1>resources :urls, only: [:new, :show, :create]</h1>

<p>```</p>

<p>Now let&rsquo;s fill in the logic for each of the actions in the Url controller.</p>

<p>```ruby UrlsController
class UrlsController &lt; ApplicationController
  def new</p>

<pre><code>@short_url = Url.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@short_url = Url.new(url_params)
if @short_url.save
    flash[:short_id] = @short_url.id
    redirect_to new_url_url
else
    render :action =&gt; "new"
end
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>@short_url = Url.find(params[:id])
redirect_to @short_url.url
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def url_params</p>

<pre><code>params.require(:url).permit(:url)
</code></pre>

<p>  end
end
```</p>

<p>In this simple case, I&rsquo;ll be resetting the link to the domain and the URL id, so it would look like this while running locally: <code>localhost:3000/f3e200091</code>. In my next refactor, I&rsquo;ll end up generating a random string, but this will do for now.</p>

<p>Let&rsquo;s move on to the views:</p>

<p>```ruby application.html.erb
&lt;!DOCTYPE html>
<html>
<head>
  <title>LinkShortener</title>
  &lt;%= stylesheet_link_tag    &ldquo;application&rdquo;, media: &ldquo;all&rdquo;, &ldquo;data-turbolinks-track&rdquo; => true %>
  &lt;%= javascript_include_tag &ldquo;application&rdquo;, &ldquo;data-turbolinks-track&rdquo; => true %>
  &lt;%= csrf_meta_tags %>
</head>
<body></p>

<p>&lt;%= yield %></p>

<p>&lt;% if flash[:short_id].present? %></p>

<pre><code>&lt;p class='shortened_link'&gt;
    The shortened URL is available &lt;%= link_to "here", url_url(flash[:short_id]) %&gt;
    (Right click and copy link to share it).
&lt;/p&gt;
</code></pre>

<p>&lt;% end %></p>

<p></body>
</html>
```</p>

<p>```ruby new.html.erb
&lt;%= form_for @short_url do |f| %></p>

<pre><code>&lt;p&gt;
    &lt;%= f.label :url, "Your URL:" %&gt;
    &lt;%= f.text_field :url %&gt;
&lt;/p&gt;

&lt;% if @short_url.errors[:url].any? %&gt;
    &lt;p class="error_messages"&gt;
        The given URL &lt;%= @short_url.errors[:url].to_sentence %&gt;
    &lt;/p&gt;
&lt;% end %&gt;

&lt;p class="button"&gt;
    &lt;%= f.submit "Shorten my URL" %&gt;
&lt;/p&gt;
</code></pre>

<p>&lt;% end %>
```</p>

<p>These two views are all you need to enable the link shortener. Fire up the rails server, and see your new link shortener in action!</p>

<br />


<p>EDIT: I incorrectly asserted that a MongoDB document element is similar to that of a key-value pair, and the appropriate revisions have been made. Many thanks to Myles Recny for catching that error.</p>
]]></content>
  </entry>
  
</feed>
