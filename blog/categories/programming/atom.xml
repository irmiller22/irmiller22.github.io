<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Archaic Positives]]></title>
  <link href="http://ianmiller.nyc/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://ianmiller.nyc/"/>
  <updated>2014-11-20T10:16:39-05:00</updated>
  <id>http://ianmiller.nyc/</id>
  <author>
    <name><![CDATA[Ian Miller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Voice in the Background]]></title>
    <link href="http://ianmiller.nyc/blog/2014/11/04/the-voice-in-the-background/"/>
    <updated>2014-11-04T12:02:37-05:00</updated>
    <id>http://ianmiller.nyc/blog/2014/11/04/the-voice-in-the-background</id>
    <content type="html"><![CDATA[<h1>Managing Uncertain Expectations</h1>

<p>{% img center <a href="http://recruiterpoet.files.wordpress.com/2011/11/white2.jpg">http://recruiterpoet.files.wordpress.com/2011/11/white2.jpg</a> %}</p>

<p>When I started programming over a year ago, I kept second guessing myself every step of the way because I believed that I truly didn’t know how to solve a problem or implement code correctly. I also believed that I was a burden on others, and the best strategy was to keep my banal questions to myself. Looking back, I wasted so much time and effort tricking myself into believing that I wasn’t good enough, and that I never would reach a state in which I was content with my abilities. I had no idea that I wasn’t alone.</p>

<h3>To self-criticize is Human</h3>

<p>Humans by nature are very critical, sometimes overbearing creatures, and we tend to come down hard on our own inabilities to overcome small obstacles, often attributing them to some inherent flaw in our mental make-up. This humanistic trait essentially makes it even more difficult when it comes to learning something new. We fault ourselves for not being able to get it right away, and we give up either out of desperation or because we fear how much we don&rsquo;t know. As a result, we&rsquo;re mentally hard-wired to set ourselves up for failure.</p>

<p>{% img center <a href="http://core0.staticworld.net/images/idge/imported/article/itw/2013/12/10/2_5-100522019-orig.jpg">http://core0.staticworld.net/images/idge/imported/article/itw/2013/12/10/2_5-100522019-orig.jpg</a> %}</p>

<h3>Perspective is Everything</h3>

<p>As an Instructor for the Web Development curriculum at the <a href="https://twitter.com/flatironschool">Flatiron School</a>, the responsibilities I typically have each day range from bug hotfixes to in-depth explanations of how the Rails framework handles controller logic. But another, less obvious part of my job is constantly helping others keep their expectations in check. From the start, we tell our students that it’s important to keep their skill level in perspective—that the path to becoming a better developer is a slow upward trajectory. We tell them, ”you will never feel as dumb as you did today.”</p>

<p>So what exactly is <a href="http://en.wikipedia.org/wiki/Impostor_syndrome">impostor syndrome</a>? Simply put, it is the feeling that &ldquo;we are frauds and we do not deserve the success we have achieved. Proof of success is dismissed as luck, timing, or as a result of deceiving others into thinking that they are more intelligent and competent than they believe themselves to be.&rdquo; Even more simply put, it is an incongruous perspective — the act of people with actual ability <strong>underestimating</strong> their relative competence.</p>

<p>{% img center <a href="http://likecrystal.com/wp-content/uploads/2013/08/another-cat-imposter.jpg">http://likecrystal.com/wp-content/uploads/2013/08/another-cat-imposter.jpg</a> %}</p>

<p>At some point in their career, a developer will experience impostor syndrome in some way, shape, or form. How they manage those feelings of insecurity depends on what strategies or techniques they decide to use.</p>

<h3>Impostor Epidemic</h3>

<p>It wasn’t until I started at my first programming job that I really started to feel inadequate, and I kept trying to convince myself that I couldn’t fulfill the project assignments I was given each week. I spent a lot of time trying to justify why I wasn’t qualified, and less time on praising the progress I had made since I made the decision to change careers into programming. I essentially spent a lot of time trying to attribute my success in my first few months to sheer luck or the efforts of others.</p>

<p>Simply put, you will never completely eradicate the presence of impostor syndrome. But you can manage it effectively through positive reinforcement and open dialogue. I was very fortunate to work with a group that held a feedback session every Friday, and on one Friday, I brought up my feelings with my team. I was surprised to find that my feelings were widely shared—even among the senior developers that I worked with.</p>

<h3>Dealing with Imposter Syndrome</h3>

<p>Coming into programming from an accelerated learning route (via Flatiron School), this is something that our students run into firsthand. Going through the process of learning the nuances of Ruby, Sinatra, Rails, Javascript, and ultimately how to build a functioning web application can be extremely daunting. Even more so is the fact that they slowly have to remove their hands from the guardrails in order to stand on your own as a developer. This was the most challenging part about my own experience, and this is something our students face every semester.</p>

<p><strong>Stay positive</strong>. It’s important to keep in perspective how far you’ve come in such a short amount of time. Play up your successes, and think about your failures, and how you can learn from them. It doesn’t matter how many times you fall—what ultimately defines you as a developer is that you continue to get back up, and recognize that there will always be moments of uncertainty and discomfort.</p>

<p><strong>Talk about it</strong>. The realization that everyone felt the way I did was huge. With the help of others, I started using several techniques to keep my doubts about my abilities in check—like positive reinforcement from friends and co-workers, and journal entries. I started participating in weekly code talks called <a href="http://www.codenewbie.org/">Code Newbie</a> that my friend, the amazingly talented and wonderful <a href="https://twitter.com/saronyitbarek">Saron Yitbarek</a>, started and currently maintains. She spoke about her experience at <a href="http://bloggytoons.com/code-club/">RailsConf 2014</a> and in this <a href="http://blog.flatironschool.com/post/102875482158/from-business-development-to-web-development-a">post</a>.</p>

<p>  {% img center <a href="http://i.imgur.com/jIVhTbP.gif">http://i.imgur.com/jIVhTbP.gif</a> %}</p>

<p><strong>Be OK with not knowing everything</strong>. I’ve had to figure out how to be OK with (excited, even!) to not know everything—it’s an opportunity to learn new things and refine my current skills. If you’re a new developer, it’s fine to acknowledge the long path ahead of you. But know that you owe it to yourself to enjoy the process of learning along the way. Accept the fact that you will never know everything there is to know about programming, and that is fine. It should be about shared experiences and delayed gratification. Take pride in new skills, incremental returns, and be excited for the programmer you’ll become.</p>

<p><strong>Learn with others and let them teach you</strong>. The best piece of advice I can give is that learning to become a programmer should not be an isolated, but rather a shared, experience. Through others, particularly a mentor, you can receive the validation and gentle push necessary to see you through the more challenging obstacles. Go to Meetups. Reach out to a developer that you like or admire. Emulate their workflow through observation. Build a web application on the side with a friend. Great software developers are the sum of their aggregated experiences over time. I guarantee you that they’ve experience more failures than they have successes. You never know what may come of your efforts unless you try.</p>

<h3>Believe in yourself</h3>

<p>No one can predict the future. It is full of unknowns, and there are bound to be curve balls thrown here and there. It&rsquo;s very easy to convince yourself that you are a tiny fragment of what you really are. Despite the dark storm clouds of negativity or belittlement that may gather in your mind, believe in yourself. Temper your lofty expectations. Adapt. Empower. Share. As Bruce Feiler says, &ldquo;take a walk with a turtle. And behold the world in pause.&rdquo;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abstraction: Path to Simplicity]]></title>
    <link href="http://ianmiller.nyc/blog/2013/10/30/a-new-addendum/"/>
    <updated>2013-10-30T22:15:00-04:00</updated>
    <id>http://ianmiller.nyc/blog/2013/10/30/a-new-addendum</id>
    <content type="html"><![CDATA[<p>Abstraction is a concept that I have been thinking quite a lot about lately.  It is a concept that has largely been foreign to me, and it is slowly dawning on me that abstraction lies all around us.</p>

<p>The Webster Dictionary defines abstraction as a &ldquo;general idea or quality rather than an actual person, object, or event.&rdquo;  If we took the literal translation of the root abstractus (past participle of abstrahere), we would get &ldquo;to draw away; to detach or divert.&rdquo;  This term was first used by Oswald Herzog to describe the artistic attitudes and implementations of the Dadaists (in 1519, &lsquo;Der Abstrakte Expressionismus&rsquo;).  He wrote, &ldquo;it is pure creation.  It does not borrow objects from the real world; it creates its own objects &hellip; the abstract reveals the will of the artist; it becomes expression.&rdquo;  Abstraction, in the general sense of the word, is the process by which we generate semantic meaning with a concept.</p>

<p>In Ruby, abstraction is key to making your code achieve two things: more readable and reusable.  At this point, we&rsquo;ve learned to make our code more abstract via many concepts, such as MVC, ReST (Representational State Transfer), migrations, database abstraction via ActiveRecord, and routing.</p>

<p>{%img center <a href="http://betweengo.com/docs/intro_rails/img/request_cycle.png">http://betweengo.com/docs/intro_rails/img/request_cycle.png</a> %}</p>

<p>A major component of Ruby on Rails has really nailed down the abstract aspect of coding for me: ActiveRecord and its corresponding ActionPacks.  ActiveRecord serves as the &ldquo;Model&rdquo; component relational database for Rails.  It comes with a set of query methods used for creating, retrieving, updating, or destroying data in the database.  The model also is used for establishing association between classes.  For example, a king could have a &ldquo;has_many&rdquo; relationship with his subjects, while a subject has a &ldquo;belongs_to&rdquo; relationship with his king.</p>

<pre><code class="ruby Monarchy Association">class King &lt; ActiveRecord::Base
    has_many :subjects
    has_many :lords
end

class Subject &lt; ActiveRecord::Base
    belongs_to :king
    belongs_to :lord
    has_many :children
end
</code></pre>

<p>ActionController serves as the &ldquo;Controller&rdquo; engine of Rails.  By definition, a controller acts as the intermediary between the views and the models, and shuttles along HTTP responses, view renders, and redirects between the two.  The controller logic is encapsulated into each individual method, and each method should really have only one action in order to simplify the logic behind the controller.  The controller is designed to encapsulate the logic behind the app into specific CRUD methods, as shown below.</p>

<pre><code class="ruby Subjects Controller">class SubjectsController &lt; ApplicationController
    before_action :set_subject, only: [:show, :edit, :update, :destroy]

  def index
    @subjects = Subject.all
  end

  def create
    Subject.create(retrieve_subject_params)
    redirect_to subjects_path
  end

  def new
    @subject = Subject.new
    @lords = Lord.all
  end

  def edit
    @subject
  end

  def show
    @subject
  end

  def update
    @subject.update(retrieve_subject_params)
    redirect_to subjects_path
  end

  def destroy
    @subject.destroy
    redirect_to subjects_path
  end


  private
  def set_subject
    @subject = Subject.find(params[:id])
  end

  def retrieve_subject_params
    params.require(:subject).permit(:name, :region, :lord_id, :class)
  end
end
</code></pre>

<p>ActionDispatch serves as a routing engine.  It is responsible for recognizing a path as specified in the model logic and dispatching it according to that route&rsquo;s specific action.  A route action should do only one thing, while keeping in convention via the &ldquo;fat model, skinny controller&rdquo; paradigm.  ActionDispatch takes care of the majority of your routes through resource routing.  With Rails, we can declare our <code>index, show, new, edit, create, update, and destroy</code> routes with one single line of code.  For example, if we wanted to have a resource for our king, subject, and lord classes, you&rsquo;d simply do the following:</p>

<pre><code class="ruby Resources for King">KingdomOfValyria::Application.routes.draw do
  resources :kings
  resources :subjects
  resources :lords

  root 'front#index'
end
</code></pre>

<p>ActionView is the Rails engine responsible for maintaining the HTML views that are rendered to the browser.  For each controller that&rsquo;s present in the app, there is a corresponding <code>app/views</code> directory that stores ERB templates used for HTML browser rendering.</p>

<p>&#8220;`ruby Subject View</p>

<h1><%= @subject.name %> - Subject of King <%= @subject.king.name %></h1>


<p><p>Lord: &lt;%= @subject.lord.name %></p>
<p>Lives: &lt;%= link_to @subject.region, @subject.region %></a></p>
&lt;% unless @subject.children.empty? %>
  <h2>Children</h2>
  <ol>
    &lt;% @subject.children.each do |child| %>
      <li>&lt;%= link_to child.name, child %></li>
    &lt;% end %>
  </ol><br>
&lt;% end %>
&lt;%= link_to &ldquo;Back&rdquo;, subjects_path %>
&lt;%= link_to &ldquo;Edit&rdquo;, edit_subject_path %>
&lt;%= link_to &ldquo;Delete&rdquo;, @subject, method: :delete %>
&#8220;`</p>

<p>Being able to effectively encapsulate your logic into separate logic categories is such a necessary skill-set to understand in order to become a proficient Ruby on Rails developer.  I&rsquo;m still in the process of learning how to whittle down my logic into singular methods and actions.  Ruby is a language that was built for abstraction.  It is meant to simplify logic in your code, and as Matz said once, &ldquo;I hope to see Ruby help every programmer in the world to be productive, and to enjoy programming, and to be happy.&rdquo;</p>
]]></content>
  </entry>
  
</feed>
